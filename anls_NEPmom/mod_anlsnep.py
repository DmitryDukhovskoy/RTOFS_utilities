"""
  Auxilary functions for NEP analsysis
"""
import numpy as np
import os
import matplotlib.pyplot as plt

def find_NWP_shelf(HH, LON, LAT, DX, DY, z0):
  """
    Generate two contours: along the 400 m and on land to 
    track the shelf water
  """
  import mod_misc1 as mmisc1

  IJL = [[294.64531249999993, 50.9375],
          [283.98906249999993, 80.22656249999999],
          [269.603125, 127.34374999999999],
          [261.07812499999994, 180.828125],
          [248.29062499999998, 206.29687499999994],
          [238.16718749999995, 217.75781249999994],
          [234.43749999999994, 249.59374999999994],
          [233.90468749999997, 272.51562499999994],
          [244.02812499999993, 296.71093749999994],
          [261.6109375, 327.27343749999994],
          [268.53749999999997, 354.01562499999994],
          [268.53749999999997, 369.29687499999994],
          [262.67656249999993, 379.48437499999994],
          [261.07812499999994, 387.12499999999994],
          [263.20937499999997, 408.77343749999994],
          [263.20937499999997, 432.96874999999994],
          [263.74218749999994, 457.1640624999999],
          [256.2828125, 478.8124999999999],
          [254.68437499999993, 499.1874999999999],
          [246.15937499999995, 525.9296874999999],
          [237.10156249999994, 538.6640624999999],
          [229.10937499999997, 548.8515624999999],
          [217.38749999999996, 555.2187499999999],
          [204.59999999999997, 561.5859374999999],
          [183.82031249999997, 566.6796874999999],
          [163.04062499999998, 569.2265624999999],
          [139.59687499999998, 573.0468749999999],
          [120.41562499999998, 580.6874999999999],
          [109.75937499999998, 585.7812499999999]]
    
  IJL = np.array(IJL).astype('int')

  IJW =  [[284.52187499999997, 44.5703125],
          [279.19374999999997, 47.1171875],
          [271.20156249999997, 56.03125],
          [266.40624999999994, 72.58593749999999],
          [250.95468749999998, 113.33593749999999],
          [250.42187499999994, 128.6171875],
          [253.08593749999994, 133.7109375],
          [251.48749999999995, 151.5390625],
          [250.95468749999998, 175.734375],
          [247.75781249999994, 187.1953125],
          [241.89687499999997, 192.2890625],
          [232.30624999999995, 196.10937499999994],
          [228.57656249999997, 211.39062499999994],
          [223.24843749999997, 248.32031249999994],
          [224.31406249999995, 268.69531249999994],
          [228.57656249999997, 292.89062499999994],
          [236.56874999999997, 315.81249999999994],
          [255.21718749999997, 348.92187499999994],
          [255.21718749999997, 360.38281249999994],
          [247.75781249999994, 393.49218749999994],
          [240.29843749999998, 431.69531249999994],
          [242.42968749999994, 467.3515624999999],
          [244.02812499999993, 488.9999999999999],
          [237.10156249999994, 506.8281249999999],
          [226.97812499999995, 525.9296874999999],
          [210.99374999999995, 534.8437499999999],
          [182.75468749999996, 532.2968749999999],
          [157.17968749999997, 534.8437499999999],
          [149.18749999999997, 542.4843749999999],
          [130.53906249999997, 547.5781249999999],
          [108.16093749999999, 570.4999999999999]]

  IJW = np.array(IJW).astype('int')

  IIL, JJL = mmisc1.polysegm_indx(IJL[:,0], IJL[:,1]) 
  IIW, JJW = mmisc1.polysegm_indx(IJW[:,0], IJW[:,1]) 

# 

# Distance along the line:
  nnw   = np.shape(IIW)[0]
  LDX   = np.zeros((nnw))
#  DLAND = np.zeros((nnw))
  ISH   = np.zeros((nnw,2)).astype('int')
  JSH   = np.zeros((nnw,2)).astype('int')
  for ii in range(nnw-1):
    i0 = IIW[ii]
    j0 = JJW[ii]
    i1 = IIW[ii+1]
    j1 = JJW[ii+1]
# Find closest point on the land contour:
    DD   = np.sqrt((IIL-i0)**2 + (JJL-j0)**2)
    iLnd = np.argmin(DD) 
    il   = IIL[iLnd]
    jl   = JJL[iLnd]

    ld = DX[j0,i0]*abs(i1-i0) + DY[j0,i0]*abs(j1-j0)
    LDX[ii+1] = ld

    Iln, Jln = mmisc1.polysegm_indx([i0,il],[j0,jl])
    hb   = HH[Jln,Iln]
    kk   = min(np.where(hb>=z0)[0])
# Check for narrow shelf to avoid all nans
    hb0 = HH[Jln[kk:],Iln[kk:]]
    if np.min(hb0) > 0.:
      kk   = max(np.where(hb<0.)[0])
      hbN  = HH[Jln[kk], Iln[kk]]
      print(f"ii={ii}, Narrow shelf, added h={hbN}")

    iSh1 = Iln[kk]
    iSh2 = il
    jSh1 = Jln[kk]
    jSh2 = jl

    ISH[ii,:] = [iSh1, iSh2]
    JSH[ii,:] = [jSh1, jSh2]
    ShI       = Iln[kk:].astype('int')
    ShJ       = Jln[kk:].astype('int')
      

# Distance along the coast:
    if ii>0:
      jl1  = JSH[ii,1]
      il1  = ISH[ii,1]
      jl0  = JSH[ii-1,1]
      il0  = ISH[ii-1,1]
      lon0 = LON[jl0,il0]
      lat0 = LAT[jl0,il0]
      lon1 = LON[jl1,il1]
      lat1 = LAT[jl1,il1]
      Dlnd = mmisc1.dist_sphcrd(lat0, lon0, lat1, lon1) 
#      DLAND[ii] = Dlnd
      if Dlnd > 1.e-3: ShIJ.add_data(ShI, ShJ, Dlnd)
    else:
      ShIJ = shelf_indx(ShI, ShJ, 0.)
     
  IJland  = np.column_stack((IIL,JJL))
  IJocean = np.column_stack((IIW,JJW))
  return ShIJ, IJland, IJocean

class shelf_indx():
  kind = 'Shelf indices'

  def __init__(self, I, J, Dst):
    self.I   = [I]
    self.J   = [J]
    self.Dst = [Dst]

  def add_data(self, I, J, Dst):
    self.I.append(I)
    self.J.append(J)
    self.Dst.append(Dst)

  








   

 
